#!/bin/bash
set -eo pipefail

VERSION="0.1.0"
IMAGE="c3po"

# --- Container naming ---
# Deterministic name from workspace path so exec/stop/status can find it.
WORKSPACE="$(pwd)"
WORKSPACE_HASH=$(printf '%s' "$WORKSPACE" | md5sum | cut -c1-8)
WORKSPACE_NAME=$(basename "$WORKSPACE" | tr -c 'a-zA-Z0-9_.-' '-' | head -c 50)
CONTAINER_NAME="c3po-${WORKSPACE_NAME}-${WORKSPACE_HASH}"

# --- Help ---
show_help() {
    cat <<'EOF'
Usage: c3po [flags] [claude args...]    Start Claude in a container (default)
       c3po exec [cmd...]               Run a command in the running container (default: bash)
       c3po attach [claude args...]     Resume Claude session in existing container
       c3po stop                        Stop and remove the container
       c3po status                      Show running c3po containers
       c3po logs [flags]                Show container logs
       c3po build [flags]               Build the c3po Docker image

Flags:
  --help, -h      Show this help message
  --version       Show version
  --shell         Start a bash shell instead of Claude (ephemeral)
  --ephemeral     Old behavior: container removed when Claude exits
  --no-resume     (attach) Start a fresh session instead of resuming
  --image <name>  Use a custom Docker image (default: c3po)
  -v, --volume <spec>  Additional volume mount (repeatable)
  --safely-require-permissions   Require Claude permission prompts (default: skip)
  --              Pass remaining args directly to docker run

Examples:
  c3po                              Start Claude, container persists after exit
  c3po -p "fix the bug"            Run with a prompt
  c3po --ephemeral                  One-shot, container removed on exit
  c3po --image my-c3po              Use a custom image
  c3po -v /data:/data               Mount an additional volume
  c3po -- --memory=4g --cpus=2      Pass flags to docker run
  c3po -p "fix bug" -- --memory=4g  Combine c3po and docker flags
  c3po exec                        Bash shell in the running container
  c3po exec nvim .                  Open neovim in the running container
  c3po attach                      Resume last Claude session in container
  c3po attach --no-resume           Start a fresh session instead
  c3po attach --resume              Interactive session picker
  c3po --safely-require-permissions  Run Claude with permission prompts enabled
  c3po attach --safely-require-permissions  Attach with permission prompts
  c3po stop                        Tear down the container
  c3po status                      List all c3po containers
  c3po logs --follow                Follow container logs
  c3po build --no-cache             Rebuild image without cache

Environment variables:
  ANTHROPIC_API_KEY                 API key (forwarded to container)
  CLAUDE_CODE_OAUTH_TOKEN           OAuth token (forwarded to container)
EOF
}

# --- Subcommands ---

cmd_exec() {
    if ! docker container inspect "$CONTAINER_NAME" &>/dev/null; then
        echo "No container found for this workspace." >&2
        echo "Start one with: c3po" >&2
        exit 1
    fi
    if [ "$(docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" != "true" ]; then
        echo "Container exists but is not running." >&2
        echo "Remove it with: c3po stop" >&2
        exit 1
    fi
    if [ $# -eq 0 ]; then
        set -- bash
    fi
    exec docker exec -it -w /workspace "$CONTAINER_NAME" "$@"
}

cmd_attach() {
    if ! docker container inspect "$CONTAINER_NAME" &>/dev/null; then
        echo "No container found for this workspace." >&2
        echo "Start one with: c3po" >&2
        exit 1
    fi
    if [ "$(docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" != "true" ]; then
        echo "Container exists but is not running." >&2
        echo "Remove it with: c3po stop" >&2
        exit 1
    fi
    local skip_permissions=1
    local auto_continue=1
    local user_has_session_flag=0
    local args=()
    for arg in "$@"; do
        case "$arg" in
            --safely-require-permissions)
                skip_permissions=0
                ;;
            --no-resume)
                auto_continue=0
                ;;
            --continue|-c|--resume|-r)
                user_has_session_flag=1
                args+=("$arg")
                ;;
            *)
                args+=("$arg")
                ;;
        esac
    done
    local claude_args=()
    if [ "$skip_permissions" = 1 ]; then
        claude_args+=(--dangerously-skip-permissions)
    fi
    if [ "$auto_continue" = 1 ] && [ "$user_has_session_flag" = 0 ]; then
        claude_args+=(--continue)
    fi
    claude_args+=("${args[@]}")
    exec docker exec -it -w /workspace "$CONTAINER_NAME" claude "${claude_args[@]}"
}

cmd_stop() {
    if ! docker container inspect "$CONTAINER_NAME" &>/dev/null; then
        echo "No container found for this workspace."
        return
    fi
    docker stop "$CONTAINER_NAME" 2>/dev/null || true
    docker rm "$CONTAINER_NAME" 2>/dev/null || true
    echo "Stopped: $CONTAINER_NAME"
}

cmd_status() {
    docker ps -a --filter "name=^c3po-" --format "table {{.Names}}\t{{.Status}}\t{{.RunningFor}}"
}

cmd_logs() {
    docker logs "$@" "$CONTAINER_NAME"
}

cmd_build() {
    local script_dir
    script_dir="$(cd "$(dirname "$0")" && pwd)"
    docker build "$@" -t "$IMAGE" "$script_dir"
}

cmd_run() {
    # Pre-flight: check docker is available
    if ! command -v docker &>/dev/null; then
        echo "Error: docker not found. Install Docker or set CONTAINER_RUNTIME." >&2
        exit 1
    fi

    local ephemeral=0
    local shell_mode=0
    local permissions=0
    local image_override=""
    local extra_volumes=()
    local docker_args=()
    local args=()

    # Parse flags
    while [ $# -gt 0 ]; do
        case "$1" in
            --ephemeral)
                ephemeral=1
                shift
                ;;
            --shell)
                shell_mode=1
                shift
                ;;
            --safely-require-permissions)
                permissions=1
                shift
                ;;
            --image)
                image_override="$2"
                shift 2
                ;;
            -v|--volume)
                extra_volumes+=("$2")
                shift 2
                ;;
            --)
                shift
                docker_args+=("$@")
                break
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # Apply image override
    if [ -n "$image_override" ]; then
        IMAGE="$image_override"
    fi

    # Pre-flight: check image exists
    if ! docker image inspect "$IMAGE" &>/dev/null; then
        echo "Image '$IMAGE' not found. Build it with: c3po build" >&2
        exit 1
    fi

    # Shell mode is always ephemeral
    if [ "$shell_mode" = 1 ]; then
        ephemeral=1
    fi

    # Check for existing container
    if docker container inspect "$CONTAINER_NAME" &>/dev/null; then
        if [ "$(docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" = "true" ]; then
            echo "Container already running for this workspace: $CONTAINER_NAME" >&2
            echo "" >&2
            echo "  c3po exec        Open a shell in the container" >&2
            echo "  c3po attach      Start a new Claude session" >&2
            echo "  c3po stop        Stop and remove the container" >&2
            exit 1
        else
            # Stopped container — remove it before starting fresh
            docker rm "$CONTAINER_NAME" &>/dev/null || true
        fi
    fi

    # Ensure host ~/.claude exists
    mkdir -p "$HOME/.claude"

    # Environment passthrough
    local env_args=()
    [ -n "$ANTHROPIC_API_KEY" ] && env_args+=(-e "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
    [ -n "$CLAUDE_CODE_OAUTH_TOKEN" ] && env_args+=(-e "CLAUDE_CODE_OAUTH_TOKEN=$CLAUDE_CODE_OAUTH_TOKEN")

    # Build docker run arguments
    local run_args=(
        --init
        --hostname c3po
        --name "$CONTAINER_NAME"
        -v "$(pwd):/workspace:rw"
        -v "$HOME/.claude:/home/claude/.claude:rw"
        --cap-drop=ALL
        --security-opt=no-new-privileges:true
        --pids-limit=1024
        --network=bridge
    )

    # Git config + credentials (read-only)
    [ -f "$HOME/.gitconfig" ] && run_args+=(-v "$HOME/.gitconfig:/home/claude/.gitconfig:ro")
    [ -f "$HOME/.config/git/config" ] && run_args+=(-v "$HOME/.config/git/config:/home/claude/.config/git/config:ro")
    [ -f "$HOME/.git-credentials" ] && run_args+=(-v "$HOME/.git-credentials:/home/claude/.git-credentials:ro")

    # Extra volume mounts
    for vol in "${extra_volumes[@]}"; do
        run_args+=(-v "$vol")
    done

    # Docker passthrough args
    run_args+=("${docker_args[@]}")

    if [ "$ephemeral" = 1 ]; then
        run_args+=(-it --rm)

        if [ "$permissions" = 1 ]; then
            run_args+=(-e C3PO_PERMISSIONS=1)
        fi

        run_args+=("${env_args[@]}")

        if [ "$shell_mode" = 1 ]; then
            run_args+=(--entrypoint /bin/bash)
        fi

        run_args+=("$IMAGE")
        run_args+=("${args[@]}")

        exec docker run "${run_args[@]}"
    fi

    # --- Persist mode: start detached, launch Claude via docker exec ---
    run_args+=(-d -e C3PO_PERSIST=1)

    if [ "$permissions" = 1 ]; then
        run_args+=(-e C3PO_PERMISSIONS=1)
    fi

    run_args+=("${env_args[@]}")
    run_args+=("$IMAGE")

    docker run "${run_args[@]}" >/dev/null

    # Wait for container to be running (poll, max ~5s)
    local retries=0
    while [ "$(docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" != "true" ]; do
        retries=$((retries + 1))
        if [ "$retries" -gt 50 ]; then
            echo "Container failed to start." >&2
            docker logs "$CONTAINER_NAME" 2>&1 >&2 || true
            docker rm "$CONTAINER_NAME" &>/dev/null || true
            exit 1
        fi
        sleep 0.1
    done

    # Build claude args and launch via docker exec
    local claude_args=()
    [ "$permissions" != 1 ] && claude_args+=(--dangerously-skip-permissions)
    claude_args+=("${args[@]}")

    docker exec -it -w /workspace "$CONTAINER_NAME" claude "${claude_args[@]}" || true

    # User is back at host shell — print persist info
    if [ "$(docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" = "true" ]; then
        echo ""
        echo "[c3po] Claude exited. Container persisting."
        echo "[c3po] Use 'c3po exec' for shell, 'c3po attach' for Claude, 'c3po stop' to terminate."
    else
        echo ""
        echo "[c3po] Container stopped."
    fi
}

# --- Dispatch ---
case "${1:-}" in
    --help|-h)
        show_help
        exit 0
        ;;
    --version)
        echo "c3po $VERSION"
        exit 0
        ;;
    exec)
        shift
        cmd_exec "$@"
        ;;
    attach)
        shift
        cmd_attach "$@"
        ;;
    stop)
        cmd_stop
        ;;
    status)
        cmd_status
        ;;
    logs)
        shift
        cmd_logs "$@"
        ;;
    build)
        shift
        cmd_build "$@"
        ;;
    *)
        cmd_run "$@"
        ;;
esac
